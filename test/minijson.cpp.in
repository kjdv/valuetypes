#include <gtest/gtest.h>
#include <stdexcept>
#include <cassert>
#include <string>
#include <variant>
#include <optional>
#include <type_traits>

namespace {

template <typename T>
struct is_optional: std::false_type
{};

template <typename T>
struct is_optional<std::optional<T>>: std::true_type
{};

template <typename T>
constexpr bool is_optional_v = is_optional<T>::value;

${minijson_declarations}

using namespace std;
using namespace minijson;

template <typename T>
void from_json(minijson::Parser &p, T &v) {
    p.read_scalar<T>(v);
}

template <typename T>
void from_json(minijson::Parser &p, std::vector<T> &v) {
    p.read_sequence<std::vector<T>>(v, [](minijson::Parser &p2, std::vector<T> &target) {
        target.emplace_back();
        from_json(p2, target.back());
    });
}

template <typename T>
void from_json(minijson::Parser &p, std::optional<std::vector<T>> &v) {
    p.read_sequence<std::optional<std::vector<T>>>(v, [](minijson::Parser &p2, std::vector<T> &target) {
        target.emplace_back();
        from_json(p2, target.back());
    });
}

struct tokenizer_testcase {
    string        input;
    vector<token> tokens;
};

class tokenizer_test : public testing::TestWithParam<tokenizer_testcase> {
};

string token_s(const token& t) {
    return visit([&](auto&& arg) {
        using T = decay_t<decltype(arg)>;
        if constexpr(is_same_v<T, string_token>) {
            return arg.value;
        } else if constexpr(is_same_v<T, int_token>) {
            return arg.value;
        } else if constexpr(is_same_v<T, float_token>) {
            return arg.value;
        } else {
            return std::to_string(t.index());
        }
    },
                 t);
}

TEST_P(tokenizer_test, tokens) {
    auto testcase = GetParam();

    istringstream stream(testcase.input);
    Tokenizer     tok(&stream);

    for(auto&& expected : testcase.tokens) {
        token actual = tok.current();
        tok.advance();
        EXPECT_EQ(token_s(expected), token_s(actual));
    }
}

tokenizer_testcase tokenizer_testcases[] =
    {
        // empty
        {"", {eof_token{}}},

        // simple chars
        {"{", {start_mapping_token{}}},
        {"}", {end_mapping_token{}}},
        {"[", {start_sequence_token{}}},
        {"]", {end_sequence_token{}}},
        {",", {separator_token{}}},
        {":", {mapper_token{}}},

        // literals
        {"true", {true_token{}}},
        {"false", {false_token{}}},
        {"null", {null_token{}}},

        // numbers
        {"1", {int_token{"1"}}},
        {"12 ", {int_token{"12"}}},
        {"3.14", {float_token{"3.14"}}},
        {"2e7", {float_token{"2e7"}}},
        {"23e+2", {float_token{"23e+2"}}},
        {"23E-2", {float_token{"23E-2"}}},
        {"-2", {int_token{"-2"}}},
        {"+2.71", {float_token{"+2.71"}}},

        // strings
        {"\"Klaas de Vries\"", {string_token{"Klaas de Vries"}}},
        {"\"with \\\"quotes\\\"", {string_token{"with \"quotes\""}}},
        {"\"\\\\\"", {string_token{"\\"}}},
        {"\"/\"", {string_token{"/"}}},
        {"\"\\b\"", {string_token{"\b"}}},
        {"\"\\f\"", {string_token{"\f"}}},
        {"\"\\n\"", {string_token{"\n"}}},
        {"\"\\r\"", {string_token{"\r"}}},
        {"\"\\t\"", {string_token{"\t"}}},
        {"\"\\ud582\"", {string_token{"\xd5\x82"}}},
        {"\"noot\"", {string_token{"noot"}}},

        // skip whitespace
        {" \t", {eof_token{}}},
        {"\t{ ", {start_mapping_token{}}},
        {"\n[", {start_sequence_token{}}},

        // serial
        {"3 ,{\t}\"blah\" 2.72", {int_token{"3"}, separator_token{}, start_mapping_token{}, end_mapping_token{}, string_token{"blah"}, float_token{"2.72"}, eof_token{}}},
        {"{\"aap\": \"noot\"}\n", {start_mapping_token{}, string_token{"aap"}, mapper_token{}, string_token{"noot"}, end_mapping_token{}, eof_token{}}},
};

INSTANTIATE_TEST_SUITE_P(test_tokenizer,
                         tokenizer_test,
                         testing::ValuesIn(tokenizer_testcases));

TEST(tokenizer, invalid_utf8) {
    stringstream stream("\"\\ug582\"");
    try {
        Tokenizer tok(&stream);
        FAIL();
    } catch(const BadJson&) {
        SUCCEED();
    }
}

TEST(tokenizer, bad_literal) {
    stringstream stream("trfalse");
    try {
        Tokenizer tok(&stream);
        FAIL();
    } catch(const BadJson&) {
        SUCCEED();
    }
}

TEST(tokenizer, bad_token) {
    stringstream stream("!");
    try {
        Tokenizer tok(&stream);
        FAIL();
    } catch(const BadJson&) {
        SUCCEED();
    }
}

template <typename T>
void try_parse(std::string content) {
    std::stringstream stream(content);
    Parser p(&stream);
    T x{};
    p.read_scalar<T>(x);
}

TEST(badjson, exception_formatting) {
    try {
        try_parse<int>("{}");
        FAIL() << "expected an exception";
    } catch (const BadJson &e) {
        EXPECT_STREQ("unexpected token, expected integer, got {", e.what());
    }
    try {
        try_parse<bool>("{}");
        FAIL() << "expected an exception";
    } catch (const BadJson &e) {
        EXPECT_STREQ("expected either true or false, got {", e.what());
    }
    try {
        try_parse<double>("{}");
        FAIL() << "expected an exception";
    } catch (const BadJson &e) {
        EXPECT_STREQ("expected a number, got {", e.what());
    }
    try {
        try_parse<optional<int>>("nufl");
        FAIL() << "expected an exception";
    } catch (const BadJson &e) {
        EXPECT_STREQ("unexpected char in literal, expected l, got f", e.what());
    }
    try {
        try_parse<int>("$");
        FAIL() << "expected an exception";
    } catch (const BadJson &e) {
        EXPECT_STREQ("unexpected token: $", e.what());
    }
}

struct Nested {
    string value;
};

struct Struct {
    double                x{0.0};
    double                y{0.0};
    int                   n{0};
    bool                  b1{false};
    bool                  b2{true};
    string                s;
    vector<int>           v;
    optional<int>         o1;
    optional<int>         o2;
    Nested                nested;
    optional<Nested>      o3;
    optional<Nested>      o4;
    optional<vector<int>> o5;
    optional<vector<int>> o6;
    variant<int, string>  var1;
    variant<int, string>  var2;
    optional<variant<int, string>> o7;
    optional<variant<int, string>> o8;
};

TEST(parser, read_mapping) {
    stringstream stream(R"(
{
    "x": 3.14,
    "y": 2.72,
    "n": 123,
    "b1": true,
    "b2": false,
    "s": "abc",
    "v": [1, 2, 3],
    "o1": null,
    "o2": 456,
    "nested": {
        "value": "def"
    },
    "o3": null,
    "o4": {
        "value": "abc"
    },
    "o5": null,
    "o6": [4, 5, 6],
    "var1": { "int": 789 },
    "var2": { "string": "ghi" },
    "o7": null,
    "o8": { "string": "jkl" }
})");
    Parser parser(&stream);
    Struct actual;
    parser.read_mapping<Struct>(actual, [](Parser& p, Struct& target, string_view key) {
        if(key == "x") {
            from_json(p, target.x);
        } else if(key == "y") {
            from_json(p, target.y);
        } else if(key == "n") {
            from_json(p, target.n);
        } else if(key == "b1") {
            from_json(p, target.b1);
        } else if(key == "b2") {
            from_json(p, target.b2);
        } else if(key == "s") {
            from_json(p, target.s);
        } else if(key == "v") {
            from_json(p, target.v);
        } else if(key == "o1") {
            from_json(p, target.o1);
        } else if(key == "o2") {
            from_json(p, target.o2);
        } else if(key == "nested") {
            p.read_mapping<Nested>(target.nested, [](Parser& p2, Nested& n, string_view k) {
                if(k == "value") {
                    from_json(p2, n.value);
                }
            });
        } else if(key == "o3") {
            p.read_mapping<optional<Nested>>(target.o3, [](Parser& p2, Nested& n, string_view k) {
                if(k == "value") {
                    from_json(p2, n.value);
                }
            });
        } else if(key == "o4") {
            p.read_mapping<optional<Nested>>(target.o4, [](Parser& p2, Nested& n, string_view k) {
                if(k == "value") {
                    from_json(p2, n.value);
                }
            });
        } else if(key == "o5") {
            from_json(p, target.o5);
        } else if(key == "o6") {
            from_json(p, target.o6);
        } else if (key == "var1") {
            p.read_mapping<variant<int, string>>(target.var1, [](Parser &p2, variant<int, string> &v, string_view k) {
               if(k == "int") {
                   v.emplace<int>();
                   from_json(p2, get<int>(v));
               } else if(k == "string") {
                   v.emplace<string>();
                   from_json(p2, get<string>(v));
               }
            });
        } else if (key == "var2") {
            p.read_mapping<variant<int, string>>(target.var2, [](Parser &p2, variant<int, string> &v, string_view k) {
               if(k == "int") {
                   v.emplace<int>();
                   from_json(p2, get<int>(v));
               } else if(k == "string") {
                   v.emplace<string>();
                   from_json(p2, get<string>(v));
               }
            });
        } else if (key == "o7") {
            p.read_mapping<optional<variant<int, string>>>(target.o7, [](Parser &p2, variant<int, string> &v, string_view k) {
               if(k == "int") {
                   v.emplace<int>();
                   from_json(p2, get<int>(v));
               } else if(k == "string") {
                   v.emplace<string>();
                   from_json(p2, get<string>(v));
               }
            });
        } else if (key == "o8") {
            p.read_mapping<optional<variant<int, string>>>(target.o8, [](Parser &p2, variant<int, string> &v, string_view k) {
               if(k == "int") {
                   v.emplace<int>();
                   from_json(p2, get<int>(v));
               } else if(k == "string") {
                   v.emplace<string>();
                   from_json(p2, get<string>(v));
               }
            });
        }
    });

    EXPECT_TRUE(parser.is_eof());

    EXPECT_EQ(3.14, actual.x);
    EXPECT_EQ(2.72, actual.y);
    EXPECT_EQ(123, actual.n);
    EXPECT_TRUE(actual.b1);
    EXPECT_FALSE(actual.b2);
    EXPECT_EQ("abc", actual.s);

    vector<int> ve{1, 2, 3};
    EXPECT_EQ(ve, actual.v);

    EXPECT_EQ(optional<int>(), actual.o1);
    EXPECT_EQ(optional<int>(456), actual.o2);

    EXPECT_EQ("def", actual.nested.value);
    EXPECT_FALSE(actual.o3);
    EXPECT_EQ("abc", actual.o4->value);

    EXPECT_FALSE(actual.o5);
    ve = {4, 5, 6};
    EXPECT_EQ(ve, *actual.o6);

    EXPECT_EQ(789, get<int>(actual.var1));
    EXPECT_EQ("ghi", get<string>(actual.var2));
    EXPECT_FALSE(actual.o7);
    EXPECT_EQ("jkl", get<string>(*actual.o8));
}

${minijson_definitions}

} // namespace
