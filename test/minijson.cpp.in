#include <gtest/gtest.h>
#include <stdexcept>
#include <cassert>
#include <string>
#include <variant>
#include <optional>
#include <type_traits>

namespace {

template <typename T>
struct is_optional: std::false_type
{};

template <typename T>
struct is_optional<std::optional<T>>: std::true_type
{};

template <typename T>
constexpr bool is_optional_v = is_optional<T>::value;

${minijson_declarations}

using namespace std;
using namespace minijson;

struct tokenizer_testcase {
    string        input;
    vector<token> tokens;
};

class tokenizer_test : public testing::TestWithParam<tokenizer_testcase> {
};

string token_s(const token& t) {
    return visit([&](auto&& arg) {
        using T = decay_t<decltype(arg)>;
        if constexpr(is_same_v<T, string_token>) {
            return arg.value;
        } else if constexpr(is_same_v<T, int_token>) {
            return arg.value;
        } else if constexpr(is_same_v<T, float_token>) {
            return arg.value;
        } else {
            return to_string(t.index());
        }
    },
                 t);
}

TEST_P(tokenizer_test, tokens) {
    auto testcase = GetParam();

    istringstream stream(testcase.input);
    Tokenizer     tok(&stream);

    for(auto&& expected : testcase.tokens) {
        token actual = tok.current();
        tok.advance();
        EXPECT_EQ(token_s(expected), token_s(actual));
    }
}

tokenizer_testcase tokenizer_testcases[] =
    {
        // empty
        {"", {eof_token{}}},

        // simple chars
        {"{", {start_mapping_token{}}},
        {"}", {end_mapping_token{}}},
        {"[", {start_sequence_token{}}},
        {"]", {end_sequence_token{}}},
        {",", {separator_token{}}},
        {":", {mapper_token{}}},

        // literals
        {"true", {true_token{}}},
        {"false", {false_token{}}},
        {"null", {null_token{}}},

        // numbers
        {"1", {int_token{"1"}}},
        {"12 ", {int_token{"12"}}},
        {"3.14", {float_token{"3.14"}}},
        {"2e7", {float_token{"2e7"}}},
        {"23e+2", {float_token{"23e+2"}}},
        {"23E-2", {float_token{"23E-2"}}},
        {"-2", {int_token{"-2"}}},
        {"+2.71", {float_token{"+2.71"}}},

        // strings
        {"\"Klaas de Vries\"", {string_token{"Klaas de Vries"}}},
        {"\"with \\\"quotes\\\"", {string_token{"with \"quotes\""}}},
        {"\"\\\\\"", {string_token{"\\"}}},
        {"\"/\"", {string_token{"/"}}},
        {"\"\\b\"", {string_token{"\b"}}},
        {"\"\\f\"", {string_token{"\f"}}},
        {"\"\\n\"", {string_token{"\n"}}},
        {"\"\\r\"", {string_token{"\r"}}},
        {"\"\\t\"", {string_token{"\t"}}},
        {"\"\\ud582\"", {string_token{"\xd5\x82"}}},
        {"\"noot\"", {string_token{"noot"}}},

        // skip whitespace
        {" \t", {eof_token{}}},
        {"\t{ ", {start_mapping_token{}}},
        {"\n[", {start_sequence_token{}}},

        // serial
        {"3 ,{\t}\"blah\" 2.72", {int_token{"3"}, separator_token{}, start_mapping_token{}, end_mapping_token{}, string_token{"blah"}, float_token{"2.72"}, eof_token{}}},
        {"{\"aap\": \"noot\"}\n", {start_mapping_token{}, string_token{"aap"}, mapper_token{}, string_token{"noot"}, end_mapping_token{}, eof_token{}}},
};

INSTANTIATE_TEST_SUITE_P(test_tokenizer,
                         tokenizer_test,
                         testing::ValuesIn(tokenizer_testcases));

TEST(tokenizer, invalid_utf8) {
    stringstream stream("\"\\ug582\"");
    try {
        Tokenizer tok(&stream);
        FAIL();
    } catch(const BadJson&) {
        SUCCEED();
    }
}

TEST(tokenizer, bad_literal) {
    stringstream stream("trfalse");
    try {
        Tokenizer tok(&stream);
        FAIL();
    } catch(const BadJson&) {
        SUCCEED();
    }
}

TEST(tokenizer, bad_token) {
    stringstream stream("!");
    try {
        Tokenizer tok(&stream);
        FAIL();
    } catch(const BadJson&) {
        SUCCEED();
    }
}

struct Nested {
    string value;
};

struct Struct {
    double                x{0.0};
    double                y{0.0};
    int                   n{0};
    bool                  b1{false};
    bool                  b2{true};
    string                s;
    vector<int>           v;
    optional<int>         o1;
    optional<int>         o2;
    Nested                nested;
    optional<Nested>      o3;
    optional<Nested>      o4;
    optional<vector<int>> o5;
    optional<vector<int>> o6;
};

TEST(parser, read_mapping) {
    stringstream stream(R"(
{
    "x": 3.14,
    "y": 2.72,
    "n": 123,
    "b1": true,
    "b2": false,
    "s": "abc",
    "v": [1, 2, 3],
    "o1": null,
    "o2": 456,
    "nested": {
        "value": "def"
    },
    "o3": null,
    "o4": {
        "value": "abc"
    },
    "o5": null,
    "o6": [4, 5, 6]
})");
    Parser       parser(&stream);
    Struct       actual = parser.read_mapping<Struct>([](Parser& p, Struct& target, string_view key) {
        if(key == "x") {
            target.x = p.read_scalar<double>();
        } else if(key == "y") {
            target.y = p.read_scalar<double>();
        } else if(key == "n") {
            target.n = p.read_scalar<int>();
        } else if(key == "b1") {
            target.b1 = p.read_scalar<bool>();
        } else if(key == "b2") {
            target.b2 = p.read_scalar<bool>();
        } else if(key == "s") {
            target.s = p.read_scalar<string>();
        } else if(key == "v") {
            target.v = p.read_sequence<vector<int>>([](Parser& p2, vector<int>& v) {
                v.push_back(p2.read_scalar<int>());
            });
        } else if(key == "o1") {
            target.o1 = p.read_scalar<optional<int>>();
        } else if(key == "o2") {
            target.o2 = p.read_scalar<optional<int>>();
        } else if(key == "nested") {
            target.nested = p.read_mapping<Nested>([](Parser& p2, Nested& n, string_view k) {
                if(k == "value") {
                    n.value = p2.read_scalar<string>();
                }
            });
        } else if(key == "o3") {
            target.o3 = p.read_mapping<optional<Nested>>([](Parser& p2, Nested& n, string_view k) {
                if(k == "value") {
                    n.value = p2.read_scalar<string>();
                }
            });
        } else if(key == "o4") {
            target.o4 = p.read_mapping<optional<Nested>>([](Parser& p2, Nested& n, string_view k) {
                if(k == "value") {
                    n.value = p2.read_scalar<string>();
                }
            });
        } else if(key == "o5") {
            target.o5 = p.read_sequence<optional<vector<int>>>([](Parser& p2, vector<int>& v) {
                v.push_back(p2.read_scalar<int>());
            });
        } else if(key == "o6") {
            target.o6 = p.read_sequence<optional<vector<int>>>([](Parser& p2, vector<int>& v) {
                v.push_back(p2.read_scalar<int>());
            });
        }
    });

    EXPECT_TRUE(parser.is_eof());

    EXPECT_EQ(3.14, actual.x);
    EXPECT_EQ(2.72, actual.y);
    EXPECT_EQ(123, actual.n);
    EXPECT_TRUE(actual.b1);
    EXPECT_FALSE(actual.b2);
    EXPECT_EQ("abc", actual.s);

    vector<int> ve{1, 2, 3};
    EXPECT_EQ(ve, actual.v);

    EXPECT_EQ(optional<int>(), actual.o1);
    EXPECT_EQ(optional<int>(456), actual.o2);

    EXPECT_EQ("def", actual.nested.value);
    EXPECT_FALSE(actual.o3);
    EXPECT_EQ("abc", actual.o4->value);

    EXPECT_FALSE(actual.o5);
    ve = {4, 5, 6};
    EXPECT_EQ(ve, *actual.o6);
}

${minijson_definitions}

} // namespace
