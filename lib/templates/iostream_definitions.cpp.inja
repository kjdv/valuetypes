// start iostream_definitions.cpp.inja

{% if namespace %}namespace {{ namespace }} { {% endif %}
namespace {

template <typename T>
struct is_optional : std::false_type
{};

template <typename T>
struct is_optional<std::optional<T>> : std::true_type
{};

template <typename T>
constexpr bool is_optional_v = is_optional<T>::value;

template <typename T>
kjson::document convert(const T &v) {
    if constexpr (is_optional_v<T>) {
        if (v) {
            return kjson::document{};
        } else {
            return convert(*v);
        }
    } else {
        return kjson::document(v);
    }
}

template <typename T>
void convert(const kjson::document &doc, T &target) {
    if constexpr (is_optional_v<T>) {
        if (doc.is<composite::none>()) {
            target.reset();
        } else {
            target.emplace();
            convert<typename T::value_type>(doc, *target);
        }
    } else {
        target = doc.to<T>();
    }
}

## for typedef in typedefs
kjson::document convert(const {{ typedef.name }} &v) {
    return composite::make_mapping(
## for member in typedef.members
        "{{ member.name }}", convert(v.{{ member.name}}){% if not loop.is_last %},{% endif %}
## endfor
    );
}

void convert(const kjson::document &doc, {{ typedef.name}} &target) {
    auto &m = doc.as<composite::mapping>();
## for member in typedef.members
    if (auto it = m.find("{{ member.name}}"); it != m.end()) {
        convert(it->second, target.{{ member.name }});
    }
## endfor
}

## endfor

} // anonymous namespace

## for typedef in typedefs
void to_json(std::ostream& out, const {{typedef.name }} &v) {
    auto doc = convert(v);
    kjson::dump(doc, out);
}

void from_json(std::istream& in, {{ typedef.name }} &v) {
    auto doc = kjson::load(in).expect("invalid json");
    convert(doc, v);
}

## endfor
} // {% if namespace %}namespace {{ namespace }}{% endif %}

namespace std {

## for typedef in typedefs
std::ostream &operator<<(std::ostream& out, const {{typedef.namespace_name }} &v) {
    {{ namespace }}::to_json(out, v);
    return out;
}

std::istream &operator>>(std::istream& in, {{ typedef.namespace_name }} &v) {
    {{ namespace }}::from_json(in, v);
    return in;
}

## endfor
} // namespace std

// end iostream_definitions.cpp.inja
