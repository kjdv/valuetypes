// start iostream_definitions.cpp.inja

{% if namespace %}namespace {{ namespace }} { {% endif %}
namespace {

template <typename T>
struct is_optional : std::false_type
{};

template <typename T>
struct is_optional<std::optional<T>> : std::true_type
{};

template <typename T>
constexpr bool is_optional_v = is_optional<T>::value;

template <typename T>
kjson::document to_kjson(const T &v) {
    if constexpr (is_optional_v<T>) {
        if (!v) {
            return kjson::document{};
        } else {
            return to_kjson(*v);
        }
    } else {
        return kjson::document(v);
    }
}

template <typename T>
void from_kjson(const kjson::document &doc, T &target) {
    if constexpr (is_optional_v<T>) {
        if (doc.is<composite::none>()) {
            target.reset();
        } else {
            target.emplace();
            from_kjson<typename T::value_type>(doc, *target);
        }
    } else {
        target = doc.to<T>();
    }
}

## for typedef in typedefs
kjson::document to_kjson(const {{ typedef.name }} &v) {
    return composite::make_mapping(
## for member in typedef.members
        "{{ member.name }}", to_kjson(v.{{ member.name}}){% if not loop.is_last %},{% endif %}
## endfor
    );
}

void from_kjson(const kjson::document &doc, {{ typedef.name}} &target) {
    auto &m = doc.as<composite::mapping>();
## for member in typedef.members
    if (auto it = m.find("{{ member.name}}"); it != m.end()) {
        from_kjson(it->second, target.{{ member.name }});
    }
## endfor
}

## endfor

} // anonymous namespace

## for typedef in typedefs
void to_json(std::ostream& out, const {{typedef.name }} &v) {
    auto doc = to_kjson(v);
    kjson::dump(doc, out);
}

void from_json(std::istream& in, {{ typedef.name }} &v) {
    auto doc = kjson::load(in).expect("invalid json");
    from_kjson(doc, v);
}

## endfor
} // {% if namespace %}namespace {{ namespace }}{% endif %}

namespace std {

## for typedef in typedefs
std::ostream &operator<<(std::ostream& out, const {{typedef.namespace_name }} &v) {
    {{ namespace }}::to_json(out, v);
    return out;
}

std::istream &operator>>(std::istream& in, {{ typedef.namespace_name }} &v) {
    {{ namespace }}::from_json(in, v);
    return in;
}

## endfor
} // namespace std

// end iostream_definitions.cpp.inja
