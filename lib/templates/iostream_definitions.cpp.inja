// start iostream_definitions.cpp.inja

{% if namespace %}namespace {{ namespace }} { {% endif %}
namespace {

template <typename T>
kjson::document convert(const T &v) {
    return kjson::document(v);
}

template <typename T>
void convert(const kjson::document &doc, T &target) {
    if constexpr (std::is_floating_point_v<T>) {
        if (doc.is<composite::int_t>()) {
            target = static_cast<T>(doc.as<composite::int_t>());
        } else {
            target = doc.as<T>();
        }
    } else {
        target = doc.as<T>();
    }
}

## for typedef in typedefs
kjson::document convert(const {{ typedef.name }} &v) {
    return composite::make_mapping(
## for member in typedef.members
        "{{ member.name }}", v.{{ member.name}}{% if not loop.is_last %},{% endif %}
## endfor
    );
}

void convert(const kjson::document &doc, {{ typedef.name}} &target) {
    auto &m = doc.as<composite::mapping>();
## for member in typedef.members
    if (auto it = m.find("{{ member.name}}"); it != m.end()) {
        convert(it->second, target.{{ member.name }});
    }
## endfor
}

## endfor

} // anonymous namespace

## for typedef in typedefs
void to_json(std::ostream& out, const {{typedef.name }} &v) {
    auto doc = convert(v);
    kjson::dump(doc, out);
}

void from_json(std::istream& in, {{ typedef.name }} &v) {
    auto doc = kjson::load(in).expect("invalid json");
    convert(doc, v);
}

## endfor
} // {% if namespace %}namespace {{ namespace }}{% endif %}

namespace std {

## for typedef in typedefs
std::ostream &operator<<(std::ostream& out, const {{typedef.namespace_name }} &v) {
    {{ namespace }}::to_json(out, v);
    return out;
}

std::istream &operator>>(std::istream& in, {{ typedef.namespace_name }} &v) {
    {{ namespace }}::from_json(in, v);
    return in;
}

## endfor
} // namespace std

// end iostream_definitions.cpp.inja
