// start iostream_definitions.cpp.inja

{% if namespace %}namespace {{ namespace }} { {% endif %}
namespace {

template <typename T>
struct is_optional : std::false_type
{};

template <typename T>
struct is_optional<std::optional<T>> : std::true_type
{};

template <typename T>
constexpr bool is_optional_v = is_optional<T>::value;

template <typename T>
struct is_vector : std::false_type
{};

template <typename T>
struct is_vector<std::vector<T>> : std::true_type
{};

template <typename T>
constexpr bool is_vector_v = is_vector<T>::value;

## for typedef in typedefs
kjson::document to_kjson(const {{ typedef.name }} &v);
void from_kjson(const kjson::document &doc, {{ typedef.name}} &target);

## endfor

template <typename T>
kjson::document to_kjson(const T &v) {
    if constexpr (is_optional_v<T>) {
        if (!v) {
            return kjson::document{};
        } else {
            return to_kjson(*v);
        }
    } else if constexpr (is_vector_v<T>) {
        auto seq = composite::sequence();
        seq.reserve(v.size());
        std::transform(v.begin(), v.end(), std::back_inserter(seq), [](auto&& item) { return to_kjson(item); });
        return kjson::document(std::move(seq));
    } else {
        return kjson::document(v);
    }
}

template <typename T>
void from_kjson(const kjson::document &doc, T &target) {
    if constexpr (is_optional_v<T>) {
        if (doc.is<composite::none>()) {
            target.reset();
        } else {
            target.emplace();
            from_kjson(doc, *target);
        }
    } else if constexpr (is_vector_v<T>) {
        using U = typename T::value_type;

        target.clear();
        auto& as_seq = doc.as<composite::sequence>();
        std::transform(as_seq.begin(), as_seq.end(), std::back_inserter(target), [](auto&& item){
            U v{};
            from_kjson(item, v);
            return v;
        });
    } else {
        target = doc.to<T>();
    }
}

## for typedef in typedefs
kjson::document to_kjson(const {{ typedef.name }} &v) {
    return composite::make_mapping(
## for member in typedef.members
## if member.value_types
        "{{ member.name }}", std::visit([](auto&& item) {
            using T = std::decay_t<decltype(item)>;

            composite::mapping m;
## for vt in member.value_types
            {% if not loop.is_first %}else {% endif %}if constexpr (std::is_same_v<T, {{ vt.type }}>) {
                m.emplace(std::make_pair("{{ vt.name }}", to_kjson(item)));
            }
## endfor

            return kjson::document{std::move(m)};
        }, v.{{ member.name}}){% if not loop.is_last %},{% endif %}
## else
        "{{ member.name }}", to_kjson(v.{{ member.name}}){% if not loop.is_last %},{% endif %}
## endif 
## endfor
    );
}

void from_kjson(const kjson::document &doc, {{ typedef.name}} &target) {
    auto& m = doc.as<composite::mapping>();
## for member in typedef.members
    if (auto it = m.find("{{ member.name}}"); it != m.end()) {
## if member.value_types
        auto& v = it->second.as<composite::mapping>();
## for vt in member.value_types
        {% if not loop.is_first %}else {% endif %} if(auto it2 = v.find("{{ vt.name }}"); it2 != v.end()) {
            auto& t = target.{{ member.name }}.emplace<{{ vt.type }}>();
            from_kjson(it2->second, t);
        }
## endfor
## else
        from_kjson(it->second, target.{{ member.name }});
## endif
    }
## endfor
}

## endfor

} // anonymous namespace

## for typedef in typedefs
void to_json(std::ostream& out, const {{typedef.name }} &v) {
    auto doc = to_kjson(v);
    kjson::dump(doc, out);
}

void from_json(std::istream& in, {{ typedef.name }} &v) {
    auto doc = kjson::load(in).expect("invalid json");
    from_kjson(doc, v);
}

## endfor
} // {% if namespace %}namespace {{ namespace }}{% endif %}

namespace std {

## for typedef in typedefs
std::ostream &operator<<(std::ostream& out, const {{typedef.namespace_name }} &v) {
    {{ namespace }}::to_json(out, v);
    return out;
}

std::istream &operator>>(std::istream& in, {{ typedef.namespace_name }} &v) {
    {{ namespace }}::from_json(in, v);
    return in;
}

## endfor
} // namespace std

// end iostream_definitions.cpp.inja
