// start iostream_definitions.cpp.inja

{% if namespace %}namespace {{ namespace }} { {% endif %}
namespace {

template <typename T>
struct is_optional : std::false_type
{};

template <typename T>
struct is_optional<std::optional<T>> : std::true_type
{};

template <typename T>
constexpr bool is_optional_v = is_optional<T>::value;

template <typename T>
struct is_vector : std::false_type
{};

template <typename T>
struct is_vector<std::vector<T>> : std::true_type
{};

template <typename T>
constexpr bool is_vector_v = is_vector<T>::value;

## for typedef in typedefs
void to_kjson(kjson::builder &builder, const {{ typedef.name }} &v);
## endfor

template <typename T>
void to_kjson(kjson::builder &builder, const T &v) {
    if constexpr (is_optional_v<T>) {
        if (!v) {
            builder.with_none();
        } else {
            to_kjson(builder, *v);
        }
    } else if constexpr (is_vector_v<T>) {
        builder.push_sequence();
        for (auto&& item : v) {
            to_kjson(builder, item);
        }
        builder.pop();
    } else {
        builder.value(v);
    }
}

template <typename To>
To kjson_extract(kjson::scalar_t v) {
    return std::visit([](auto&& value) -> To {
        using From = std::decay_t<decltype(value)>;
        if constexpr(std::is_convertible_v<From, To>) {
            return value;
        } else if constexpr (is_optional_v<To> && std::is_same_v<From, kjson::none>) {
            return std::nullopt;
        } else {
            throw std::runtime_error("cannot convert");
        }
    }, v);
}

template <typename To>
void from_kjson(To& target, kjson::scalar_t v) {
    target = kjson_extract<To>(std::move(v));
}

// reading from json as a state machine, where the state is defined by the target structure
class populate_state {
public:
    virtual ~populate_state() = default;

    virtual void scalar(std::string_view key, kjson::scalar_t v) = 0;

    // return value indicates the next state
    virtual std::unique_ptr<populate_state> push_mapping(std::string_view key) = 0;
};

template <typename T>
struct populate_trait {
    static std::unique_ptr<populate_state> make_state(auto&& target) {
        throw std::runtime_error("conversion error - target is not a recognized struct");
    }
};

// forward state declarations:
## for typedef in typedefs
class {{ typedef.name }}_populate_state : public populate_state {
public:
    {{ typedef.name}}_populate_state({{ typedef.name }} &target);
    
    void scalar(std::string_view key, kjson::scalar_t v) override;
    std::unique_ptr<populate_state> push_mapping(std::string_view key) override;
private:
    {{ typedef.name }} &d_target;
};

template <>
struct populate_trait<{{ typedef.name }}_populate_state> {
    static std::unique_ptr<populate_state> make_state(auto&& target) {
        return std::make_unique<{{ typedef.name }}_populate_state>(std::forward(target));
    }
};

## endfor

template <typename Initial, typename Target>
class populate_state_machine : public kjson::visitor {
public:
    populate_state_machine(Target &target) : d_target(target) 
    {}

    void scalar(kjson::scalar_t v) override {
        // assert(false && "implement me");
    }

    void scalar(std::string_view key, kjson::scalar_t v) override {
        state().scalar(key, std::move(v));
    }

    void push_sequence() override {
        // assert(false && "implement me");
    }

    void push_sequence(std::string_view key) override {
        // assert(false && "implement me");
    }

    void push_mapping() override {
        if (d_states.empty()) {
            d_states.push(std::make_unique<Initial>(d_target));
        } else {
           // assert(false && "implement me");
        }
    }
    void push_mapping(std::string_view key) override {
        auto next = state().push_mapping(key);
        d_states.push(std::move(next));
    }

    void pop() override {
        assert(!d_states.empty());
        d_states.pop();
    }

  private:
    populate_state& state() {
        assert(!d_states.empty());
        return *d_states.top();
    }

    Target &d_target;
    std::stack<std::unique_ptr<populate_state>> d_states;
};

## for typedef in typedefs
void to_kjson(kjson::builder &builder, const {{ typedef.name }} &v) {
    builder.push_mapping();
## for member in typedef.members
## if member.value_types
    builder.key("{{ member.name }}");
    builder.push_mapping();
    std::visit([&builder](auto&& item) {
            using T = std::decay_t<decltype(item)>;

## for vt in member.value_types
            {% if not loop.is_first %}else {% endif %}if constexpr (std::is_same_v<T, {{ vt.type }}>) {
                builder.key("{{ vt.name }}");
                to_kjson(builder, item);
            }
## endfor
    }, v.{{ member.name}});
    builder.pop();
## else
    builder.key("{{ member.name }}");
    to_kjson(builder, v.{{ member.name }});
## endif 
## endfor
    builder.pop();
}

{{ typedef.name }}_populate_state::{{ typedef.name}}_populate_state({{ typedef.name }} &target)
    : d_target(target)
    {}
    
void {{ typedef.name }}_populate_state::scalar(std::string_view key, kjson::scalar_t v) {
## for member in typedef.members
    {% if not loop.is_first %}else {% endif %}if (key == "{{ member.name }}") {
        from_kjson(d_target.{{ member.name }}, std::move(v));
    }
## endfor
}

std::unique_ptr<populate_state> {{ typedef.name }}_populate_state::push_mapping(std::string_view key)   {
## for member in typedef.members
    {% if not loop.is_first %}else {% endif %}if (key == "{{ member.name }}") {
        return populate_trait<{{ member.type }}>::make_state(d_target.{{ member.name }});
    }
## endfor
    return nullptr;
}

## endfor

} // anonymous namespace

## for typedef in typedefs
void to_json(std::ostream& out, const {{typedef.name }} &v) {
    kjson::builder builder(out, true);
    to_kjson(builder, v);
}

void from_json(std::istream& in, {{ typedef.name }} &v) {
    populate_state_machine<{{ typedef.name }}_populate_state, {{typedef.name}}> visitor(v);
    kjson::load(in, visitor).expect("invalid json");
}

## endfor
} // {% if namespace %}namespace {{ namespace }}{% endif %}

namespace std {

## for typedef in typedefs
std::ostream &operator<<(std::ostream& out, const {{typedef.namespace_name }} &v) {
    {{ namespace }}::to_json(out, v);
    return out;
}

std::istream &operator>>(std::istream& in, {{ typedef.namespace_name }} &v) {
    {{ namespace }}::from_json(in, v);
    return in;
}

## endfor
} // namespace std

// end iostream_definitions.cpp.inja
