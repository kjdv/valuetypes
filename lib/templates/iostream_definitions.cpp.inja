// start iostream_definitions.cpp.inja

{% if namespace %}namespace {{ namespace }} { {% endif %}
namespace {

template <typename T>
struct is_optional : std::false_type
{};

template <typename T>
struct is_optional<std::optional<T>> : std::true_type
{};

template <typename T>
constexpr bool is_optional_v = is_optional<T>::value;

template <typename T>
struct is_vector : std::false_type
{};

template <typename T>
struct is_vector<std::vector<T>> : std::true_type
{};

template <typename T>
constexpr bool is_vector_v = is_vector<T>::value;

## for typedef in typedefs
void to_kjson(kjson::builder &builder, const {{ typedef.name }} &v);
## endfor

template <typename T>
void to_kjson(kjson::builder &builder, const T &v) {
    if constexpr (is_optional_v<T>) {
        if (!v) {
            builder.with_none();
        } else {
            to_kjson(builder, *v);
        }
    } else if constexpr (is_vector_v<T>) {
        builder.push_sequence();
        for (auto&& item : v) {
            to_kjson(builder, item);
        }
        builder.pop();
    } else {
        builder.value(v);
    }
}

template <typename To>
To kjson_extract(kjson::scalar_t v) {
    return std::visit([](auto&& value) -> To {
        using From = std::decay_t<decltype(value)>;
        if constexpr(std::is_convertible_v<From, To>) {
            return value;
        } else if constexpr (is_optional_v<To> && std::is_same_v<From, kjson::none>) {
            return std::nullopt;
        } else {
            throw std::runtime_error("cannot convert");
        }
    }, v);
}

template <typename To>
void from_kjson(To& target, kjson::scalar_t v) {
    target = kjson_extract<To>(std::move(v));
}

void check(kjson::maybe_error me) {
    if(me.is_err()) {
        throw std::runtime_error(me.unwrap_err().msg);
    }
}

// reading from json as a state machine, where the state is defined by the target structure
class populate_state {
public:
    virtual ~populate_state() = default;

    virtual void scalar(kjson::scalar_t v) {
        throw std::runtime_error("unexpected unkeyed scalar");
    }
    virtual void scalar(std::string_view key, kjson::scalar_t v) {
        throw std::runtime_error("unexpected keyed scalar");
    }

    // return value indicates the next state
    virtual std::unique_ptr<populate_state> push_sequence() {
        throw std::runtime_error("unexpected unkeyed sequence");
    }
    virtual std::unique_ptr<populate_state> push_sequence(std::string_view key) {
        throw std::runtime_error("unexpected keyed scalar");
    }
    virtual std::unique_ptr<populate_state> push_mapping() {
        throw std::runtime_error("unexpected unkeyed mapping");
    }
    virtual std::unique_ptr<populate_state> push_mapping(std::string_view key) {
        throw std::runtime_error("unexpected keyed mapping");
    }
};

template <typename T>
struct populate_trait {
    static std::unique_ptr<populate_state> make_state(auto& target) {
        throw std::runtime_error("conversion error - target is not a recognized struct");
    }
};

// forward state declarations:
## for typedef in typedefs
class {{ typedef.name }}_populate_state : public populate_state {
public:
    {{ typedef.name}}_populate_state({{ typedef.name }} &target);
    
    void scalar(std::string_view key, kjson::scalar_t v) override;
    std::unique_ptr<populate_state> push_sequence(std::string_view key) override;
    std::unique_ptr<populate_state> push_mapping(std::string_view key) override;
private:
    {{ typedef.name }} &d_target;
};

template <>
struct populate_trait<{{ typedef.name }}_populate_state> {
    static std::unique_ptr<populate_state> make_state(auto& target) {
        return std::make_unique<{{ typedef.name }}_populate_state>(target);
    }
};

template <>
struct populate_trait<{{ typedef.name }}> : populate_trait<{{ typedef.name }}_populate_state>
{};

## for member in typedef.members
## if member.value_type
class {{ typedef.name }}_{{ member.name }}_populate_state : public populate_state {
public:
    {{ typedef.name}}_{{ member.name }}_populate_state({{ member.type }} &target);
    
    void scalar(kjson::scalar_t v) override;
    std::unique_ptr<populate_state> push_sequence() override;
    std::unique_ptr<populate_state> push_mapping() override;
private:
    {{ member.type }} &d_target;
};

template <>
struct populate_trait<{{ typedef.name }}_{{ member.name }}_populate_state> {
    static std::unique_ptr<populate_state> make_state(auto& target) {
        return std::make_unique<{{ typedef.name }}_{{ member.name }}_populate_state>(target);
    }
};
## else if member.value_types
class {{ typedef.name }}_{{ member.name }}_populate_state : public populate_state {
public:
    {{ typedef.name }}_{{ member.name }}_populate_state({{ member.type }} &target);

    void scalar(std::string_view key, kjson::scalar_t v) override;
    std::unique_ptr<populate_state> push_mapping(std::string_view key) override;
private:
    {{ member.type }} &d_target;
};

template <>
struct populate_trait<{{ typedef.name }}_{{ member.name }}_populate_state> {
    static std::unique_ptr<populate_state> make_state(auto& target) {
        return std::make_unique<{{ typedef.name }}_{{ member.name }}_populate_state>(target);
    }
};

template <>
struct populate_trait<{{ member.type }}> : public populate_trait<{{ typedef.name }}_{{ member.name }}_populate_state>
{};

## endif
## endfor
## endfor

template <typename Initial, typename Target>
class populate_state_machine : public kjson::visitor {
public:
    populate_state_machine(Target &target) : d_target(target) 
    {}

    void scalar(kjson::scalar_t v) override {
        state().scalar(std::move(v));
    }

    void scalar(std::string_view key, kjson::scalar_t v) override {
        state().scalar(key, std::move(v));
    }

    void push_sequence() override {
        auto next = state().push_sequence();
        assert(next);
        d_states.push(std::move(next));
    }

    void push_sequence(std::string_view key) override {
        auto next = state().push_sequence(key);
        if (!next) {
            throw std::runtime_error("unexpected keyed sequence");
        }
        d_states.push(std::move(next));
    }

    void push_mapping() override {
        if (d_states.empty()) {
            d_states.push(std::make_unique<Initial>(d_target));
        } else {
            auto next = state().push_mapping();
            assert(next);
            d_states.push(std::move(next));
        }
    }
    void push_mapping(std::string_view key) override {
        auto next = state().push_mapping(key);
        if (!next) {
            throw std::runtime_error("unexpected keyed mapping");
        }
        d_states.push(std::move(next));
    }

    void pop() override {
        assert(!d_states.empty());
        d_states.pop();
    }

  private:
    populate_state& state() {
        assert(!d_states.empty());
        return *d_states.top();
    }

    Target &d_target;
    std::stack<std::unique_ptr<populate_state>> d_states;
};

## for typedef in typedefs
void to_kjson(kjson::builder &builder, const {{ typedef.name }} &v) {
    builder.push_mapping();
## for member in typedef.members
## if member.value_types
    builder.key("{{ member.name }}");
    builder.push_mapping();
    std::visit([&builder](auto&& item) {
            using T = std::decay_t<decltype(item)>;

## for vt in member.value_types
            {% if not loop.is_first %}else {% endif %}if constexpr (std::is_same_v<T, {{ vt.type }}>) {
                builder.key("{{ vt.name }}");
                to_kjson(builder, item);
            }
## endfor
    }, v.{{ member.name}});
    builder.pop();
## else
    builder.key("{{ member.name }}");
    to_kjson(builder, v.{{ member.name }});
## endif 
## endfor
    builder.pop();
}

{{ typedef.name }}_populate_state::{{ typedef.name}}_populate_state({{ typedef.name }} &target)
    : d_target(target)
    {}
    
void {{ typedef.name }}_populate_state::scalar(std::string_view key, kjson::scalar_t v) {
## for member in typedef.members
    {% if not loop.is_first %}else {% endif %}if (key == "{{ member.name }}") {
        from_kjson(d_target.{{ member.name }}, std::move(v));
    }
## endfor
}

std::unique_ptr<populate_state> {{ typedef.name }}_populate_state::push_sequence(std::string_view key) {
## for member in typedef.members
    {% if not loop.is_first %}else {% endif %}if (key == "{{ member.name }}") {
## if member.value_type
        return populate_trait<{{ typedef.name }}_{{ member.name}}_populate_state>::make_state(d_target.{{ member.name }});
## else
        return populate_trait<int>::make_state(*this); // throws 
## endif
    }
## endfor
    return nullptr;
}

std::unique_ptr<populate_state> {{ typedef.name }}_populate_state::push_mapping(std::string_view key)   {
## for member in typedef.members
    {% if not loop.is_first %}else {% endif %}if (key == "{{ member.name }}") {
        return populate_trait<{{ member.type }}>::make_state(d_target.{{ member.name }});
    }
## endfor
    return nullptr;
}

## for member in typedef.members
## if member.value_type

{{ typedef.name}}_{{ member.name }}_populate_state::{{ typedef.name}}_{{ member.name }}_populate_state({{ member.type }} &target) 
    : d_target(target) {
## if member.optional
    if (!d_target) {
        d_target.emplace();
    }
## endif
}

void {{ typedef.name}}_{{ member.name }}_populate_state::scalar(kjson::scalar_t v) {
## if member.optional
    assert(d_target && "unexpectedly null");
    d_target->emplace_back(kjson_extract<{{ member.value_type }}>(std::move(v)));
## else
    d_target.emplace_back(kjson_extract<{{ member.value_type }}>(std::move(v)));
## endif    
}

std::unique_ptr<populate_state> {{ typedef.name}}_{{ member.name }}_populate_state::push_sequence() {
## if member.optional
    assert(d_target && "unexpectedly null");
    d_target->emplace_back();
    return populate_trait<{{ member.value_type }}::value_type>::make_state(d_target->back());
## else
    d_target.emplace_back();
    return populate_trait<{{ member.value_type }}>::make_state(d_target.back());
## endif    
}

std::unique_ptr<populate_state> {{ typedef.name}}_{{ member.name }}_populate_state::push_mapping() {
## if member.optional
    assert(d_target && "unexpectedly null");
    d_target->emplace_back();
    return populate_trait<{{ member.value_type }}::value_type>::make_state(d_target->back());
## else
    d_target.emplace_back();
    return populate_trait<{{ member.value_type }}>::make_state(d_target.back());
## endif    
}

## else if member.value_types
{{ typedef.name}}_{{ member.name }}_populate_state::{{ typedef.name}}_{{ member.name }}_populate_state({{ member.type }} &target) 
    : d_target(target) {
## if member.optional
    if (!d_target) {
        d_target.emplace();
    }
## endif
}

void {{ typedef.name}}_{{ member.name }}_populate_state::scalar(std::string_view key, kjson::scalar_t v) {
## for value_type in member.value_types
    {% if not loop.is_first %}else {% endif %}if (key == "{{ value_type.name }}") {
## if member.optional
        assert(d_target && "unexpectedly null");
        d_target->emplace<{{ value_type.type }}>();
        from_kjson(std::get<{{ value_type.type }}>(*d_target), std::move(v));
## else
        d_target.emplace<{{ value_type.type }}>();
        from_kjson(std::get<{{ value_type.type }}>(d_target), std::move(v));
## endif
    }
## endfor
}

std::unique_ptr<populate_state> {{ typedef.name}}_{{ member.name }}_populate_state::push_mapping(std::string_view key) {
## for value_type in member.value_types
    {% if not loop.is_first %}else {% endif %}if (key == "{{ value_type.name }}") {
## if value_type.optional
        using T = {{ value_type.type }}::value_type;
## else
        using T = {{ value_type.type }};
## endif
## if member.optional
        assert(d_target && "unexpectedly null");
        d_target->emplace<{{ value_type.type }}>();
## if value_type.optional
        std::get<{{ value_type.type }}>(*d_target).emplace();
## endif
        return populate_trait<T>::make_state(std::get<T>(*d_target));
## else
        d_target.emplace<{{ value_type.type }}>();
## if value_type.optional
        std::get<{{ value_type.type }}>(d_target).emplace();
        return populate_trait<T>::make_state(*std::get<{{ value_type.type }}>(d_target));
## else
        return populate_trait<T>::make_state(std::get<{{ value_type.type }}>(d_target));
## endif
## endif
    }
## endfor
    return nullptr;
}

## endif
## endfor

## endfor

} // anonymous namespace

## for typedef in typedefs
void to_json(std::ostream& out, const {{typedef.name }} &v) {
    kjson::builder builder(out, true);
    to_kjson(builder, v);
}

void from_json(std::istream& in, {{ typedef.name }} &v) {
    populate_state_machine<{{ typedef.name }}_populate_state, {{typedef.name}}> visitor(v);
    check(kjson::load(in, visitor));
}

## endfor
} // {% if namespace %}namespace {{ namespace }}{% endif %}

namespace std {

## for typedef in typedefs
std::ostream &operator<<(std::ostream& out, const {{typedef.namespace_name }} &v) {
    {{ namespace }}::to_json(out, v);
    return out;
}

std::istream &operator>>(std::istream& in, {{ typedef.namespace_name }} &v) {
    {{ namespace }}::from_json(in, v);
    return in;
}

## endfor
} // namespace std

// end iostream_definitions.cpp.inja
