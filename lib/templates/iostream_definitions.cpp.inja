// start iostream_definitions.cpp.inja

{% if namespace %}namespace {{ namespace }} { {% endif %}
namespace {

template <typename T>
struct is_optional : std::false_type
{};

template <typename T>
struct is_optional<std::optional<T>> : std::true_type
{};

template <typename T>
constexpr bool is_optional_v = is_optional<T>::value;

template <typename T>
struct is_vector : std::false_type
{};

template <typename T>
struct is_vector<std::vector<T>> : std::true_type
{};

template <typename T>
constexpr bool is_vector_v = is_vector<T>::value;

## for typedef in typedefs
void to_kjson(kjson::builder &builder, const {{ typedef.name }} &v);
void from_kjson(const kjson::document &doc, {{ typedef.name}} &target);

## endfor

template <typename T>
void to_kjson(kjson::builder &builder, const T &v) {
    if constexpr (is_optional_v<T>) {
        if (!v) {
            builder.with_none();
        } else {
            to_kjson(builder, *v);
        }
    } else if constexpr (is_vector_v<T>) {
        builder.push_sequence();
        for (auto&& item : v) {
            to_kjson(builder, item);
        }
        builder.pop();
    } else {
        builder.value(v);
    }
}

template <typename T>
void from_kjson(const kjson::document &doc, T &target) {
    if constexpr (is_optional_v<T>) {
        if (doc.is<composite::none>()) {
            target.reset();
        } else {
            target.emplace();
            from_kjson(doc, *target);
        }
    } else if constexpr (is_vector_v<T>) {
        using U = typename T::value_type;

        target.clear();
        auto& as_seq = doc.as<composite::sequence>();
        std::transform(as_seq.begin(), as_seq.end(), std::back_inserter(target), [](auto&& item){
            U v{};
            from_kjson(item, v);
            return v;
        });
    } else {
        target = doc.to<T>();
    }
}

## for typedef in typedefs
void to_kjson(kjson::builder &builder, const {{ typedef.name }} &v) {
    builder.push_mapping();
## for member in typedef.members
## if member.value_types
    builder.key("{{ member.name }}");
    builder.push_mapping();
    std::visit([&builder](auto&& item) {
            using T = std::decay_t<decltype(item)>;

## for vt in member.value_types
            {% if not loop.is_first %}else {% endif %}if constexpr (std::is_same_v<T, {{ vt.type }}>) {
                builder.key("{{ vt.name }}");
                to_kjson(builder, item);
            }
## endfor
    }, v.{{ member.name}});
    builder.pop();
## else
    builder.key("{{ member.name }}");
    to_kjson(builder, v.{{ member.name }});
## endif 
## endfor
    builder.pop();
}

void from_kjson(const kjson::document &doc, {{ typedef.name}} &target) {
    auto& m = doc.as<composite::mapping>();
## for member in typedef.members
    if (auto it = m.find("{{ member.name}}"); it != m.end()) {
## if member.value_types
        auto& v = it->second.as<composite::mapping>();
## for vt in member.value_types
        {% if not loop.is_first %}else {% endif %} if(auto it2 = v.find("{{ vt.name }}"); it2 != v.end()) {
            auto& t = target.{{ member.name }}.emplace<{{ vt.type }}>();
            from_kjson(it2->second, t);
        }
## endfor
## else
        from_kjson(it->second, target.{{ member.name }});
## endif
    }
## endfor
}

## endfor

} // anonymous namespace

## for typedef in typedefs
void to_json(std::ostream& out, const {{typedef.name }} &v) {
    kjson::builder builder(out, true);
    to_kjson(builder, v);
}

void from_json(std::istream& in, {{ typedef.name }} &v) {
    auto doc = kjson::load(in).expect("invalid json");
    from_kjson(doc, v);
}

## endfor
} // {% if namespace %}namespace {{ namespace }}{% endif %}

namespace std {

## for typedef in typedefs
std::ostream &operator<<(std::ostream& out, const {{typedef.namespace_name }} &v) {
    {{ namespace }}::to_json(out, v);
    return out;
}

std::istream &operator>>(std::istream& in, {{ typedef.namespace_name }} &v) {
    {{ namespace }}::from_json(in, v);
    return in;
}

## endfor
} // namespace std

// end iostream_definitions.cpp.inja
