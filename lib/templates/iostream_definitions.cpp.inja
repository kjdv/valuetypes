// start iostream_definitions.cpp.inja

{% if namespace %}namespace {{ namespace }} { {% endif %}
namespace {

{% include "minijson_declarations" %}

template <typename T>
void to_json(ostream &out, const T &v) {
    using U = std::decay_t<T>;

    if constexpr (is_optional_v<U>) {
        if (!v) {
            out << "null";
        } else {
            to_json(out, *v);
        }
        return;
    }

    if constexpr (is_same_v<U, bool>) {
        out << boolalpha << v;
    } else if constexpr (is_floating_point_v<U>) {
        out << setprecision(18) << v;
    } else if constexpr (is_integral_v<U>) {
        out << v;
    } else if constexpr (is_same_v<U, string>) {
        out << quoted(v);
    } else if constexpr (is_vector_v<U>) {
        out << "[ ";
        bool first = true;
        for (auto&& item : v) {
            if (!first) {
                out << ", ";
            }
            to_json(out, item);
            first = false;
        }
        out << " ]";
    } else {
        assert(false && "implement me");
    }
}

## for typedef in typedefs
void from_json(minijson::Parser &p, {{ typedef.name}} &v);
## endfor

template <typename T>
void from_json(minijson::Parser &p, T &v) {
    p.read_scalar<T>(v);
}

template <typename T>
void from_json(minijson::Parser &p, std::vector<T> &v) {
    p.read_sequence<std::vector<T>>(v, [](minijson::Parser &p2, std::vector<T> &target) {
        target.emplace_back();
        from_json(p2, target.back());
    });
}

template <typename T>
void from_json(minijson::Parser &p, std::optional<std::vector<T>> &v) {
    p.read_sequence<std::optional<std::vector<T>>>(v, [](minijson::Parser &p2, std::vector<T> &target) {
        target.emplace_back();
        from_json(p2, target.back());
    });
}

## for typedef in typedefs
void from_json(minijson::Parser &p, {{ typedef.name}} &v) {
    p.read_mapping<{{ typedef.name }}>(v, [](minijson::Parser &p, {{ typedef.name }}& target, string_view key) {
## for member in typedef.members
        {% if not loop.is_first %}else {% endif %}if (key == "{{ member.name }}") {
             from_json(p, target.{{member.name}});
        }
## endfor
        else {
            throw minijson::BadJson(minijson::concat("unexpected key in struct of type {{ typedef.name}}: "));
        }
    });
}

## endfor

} // anonymous namespace

## for typedef in typedefs
void to_json(std::ostream& out, const {{typedef.name }} &v) {
    out << "{ ";
## for member in typedef.members
    out << quoted("{{ member.name }}") << ": ";
    to_json(out, v.{{member.name}});
{% if not loop.is_last %}    out << ", ";{% endif %}
## endfor
    out << " }";
}

void from_json(istream& in, {{ typedef.name }} &v) {
    minijson::Parser parser(&in);
    from_json(parser, v);
}

## endfor
namespace {
{% include "minijson_definitions" %}
} // anonymous namespace
} // {% if namespace %}namespace {{ namespace }}{% endif %}

namespace std {

## for typedef in typedefs
ostream &operator<<(ostream& out, const {{typedef.namespace_name }} &v) {
    {{ namespace }}::to_json(out, v);
    return out;
}

istream &operator>>(istream& in, {{ typedef.namespace_name }} &v) {
    {{ namespace }}::from_json(in, v);
    return in;
}

## endfor
} // namespace std

// end iostream_definitions.cpp.inja
