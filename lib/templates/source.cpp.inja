#include "{{ options.base_filename }}.h"
#include <cassert>
#include <iomanip>
#include <iostream>
#include <optional>
#include <sstream>
#include <tuple>
#include <type_traits>
#include <utility>
#include <variant>

{% if namespace %}namespace {{ namespace }} { {% endif %}

namespace {

using namespace std;

template <typename T>
struct is_optional: std::false_type
{};

template <typename T>
struct is_optional<std::optional<T>>: std::true_type
{};

template <typename T>
constexpr bool is_optional_v = is_optional<T>::value;


{% include "minijson_declarations" %}

template <typename T>
void to_json(ostream &out, const T &v) {
    using U = std::decay_t<T>;

    if constexpr (is_optional_v<U>) {
        if (!v) {
            out << "null";
        } else {
            to_json(out, *v);
        }
        return;
    }

    if constexpr (is_same_v<U, bool>) {
        out << boolalpha << v;
    } else if constexpr (is_floating_point_v<U>) {
        out << setprecision(18) << v;
    } else if constexpr (is_integral_v<U>) {
        out << v;
    } else if constexpr (is_same_v<U, string>) {
        out << quoted(v);
    } else {
        assert(false && "implement me");
    }
}

template <typename T>
T from_json(minijson::Parser &p) {
    return p.read_scalar<T>();
}

} // anonymous namespace

## for typedef in typedefs

bool operator==(const {{ typedef.name }} &a, const {{ typedef.name}} &b) noexcept {
    return
        tie({% for member in typedef.members %}a.{{ member.name }}{% if not loop.is_last %}, {% endif %}{% endfor %}) ==
        tie({% for member in typedef.members %}b.{{ member.name }}{% if not loop.is_last %}, {% endif %}{% endfor %});
}

bool operator!=(const {{ typedef.name }} &a, const {{ typedef.name}} &b) noexcept {
    return !(a == b);
}

bool operator<(const {{ typedef.name }} &a, const {{ typedef.name}} &b) noexcept {
    return
        tie({% for member in typedef.members %}a.{{ member.name }}{% if not loop.is_last %}, {% endif %}{% endfor %}) <
        tie({% for member in typedef.members %}b.{{ member.name }}{% if not loop.is_last %}, {% endif %}{% endfor %});
}

bool operator<=(const {{ typedef.name }} &a, const {{ typedef.name}} &b) noexcept {
    return !(b < a);
}

bool operator>(const {{ typedef.name }} &a, const {{ typedef.name}} &b) noexcept {
    return b < a;
}

bool operator>=(const {{ typedef.name }} &a, const {{ typedef.name}} &b) noexcept {
    return !(a < b);
}

void to_json(std::ostream& out, const {{typedef.name }} &v) {
    out << "{ ";
## for member in typedef.members
    out << quoted("{{ member.name }}") << ": ";
    to_json(out, v.{{member.name}});
{% if not loop.is_last %}    out << ", ";{% endif %}
## endfor
    out << " }";
}

void from_json(istream& in, {{ typedef.name }} &v) {
    minijson::Parser parser(&in);
    v = parser.read_mapping<{{ typedef.name }}>([](minijson::Parser &p, {{ typedef.name }}& target, string_view key) {
## for member in typedef.members
        {% if not loop.is_first %}else {% endif %}if (key == "{{ member.name }}") {
            target.{{member.name}} = from_json<{{member.type}}>(p);
        }
## endfor
    });
}

## endfor
namespace {
{% include "minijson_definitions" %}
} // anonymous namespace

} // {% if namespace %}} // namespace {{ namespace }}{% endif %}

namespace std {

namespace {

std::size_t hash_combine() {
    return 0;
}

template <typename Head, typename... Tail>
std::size_t hash_combine(const Head &head, Tail... tail) {
    hash<Head> hasher;
    auto h = hasher(head);
    auto t = hash_combine(std::forward<Tail>(tail)...);
    return t ^ (h + 0x9e3779b9 + (t << 6) + (t >> 2));
}

} // anonymous namespace

## for typedef in typedefs
ostream &operator<<(ostream& out, const {{typedef.namespace_name }} &v) {
    {{ namespace }}::to_json(out, v);
    return out;
}

istream &operator>>(istream& in, {{ typedef.namespace_name }} &v) {
    {{ namespace }}::from_json(in, v);
    return in;
}

std::size_t hash<{{typedef.namespace_name}}>::operator()(const {{typedef.namespace_name}} &v) const noexcept {
    return hash_combine({% for member in typedef.members %}v.{{ member.name }}{% if not loop.is_last %}, {% endif %}{% endfor %});
}

## endfor
} // namespace std
