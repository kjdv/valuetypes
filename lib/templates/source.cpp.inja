#include "{{ options.base_filename }}.h"
#include <cassert>
#include <iomanip>
#include <iostream>
#include <optional>
#include <sstream>
#include <tuple>
#include <type_traits>
#include <utility>
#include <variant>

{% if namespace %}namespace {{ namespace }} { {% endif %}

namespace {

using namespace std;

template <typename T>
struct is_optional: std::false_type
{};

template <typename T>
struct is_optional<std::optional<T>>: std::true_type
{};

template <typename T>
constexpr bool is_optional_v = is_optional<T>::value;

} // anonymous namespace

## for typedef in typedefs

bool operator==(const {{ typedef.name }} &a, const {{ typedef.name}} &b) noexcept {
    return
        tie({% for member in typedef.members %}a.{{ member.name }}{% if not loop.is_last %}, {% endif %}{% endfor %}) ==
        tie({% for member in typedef.members %}b.{{ member.name }}{% if not loop.is_last %}, {% endif %}{% endfor %});
}

bool operator!=(const {{ typedef.name }} &a, const {{ typedef.name}} &b) noexcept {
    return !(a == b);
}

bool operator<(const {{ typedef.name }} &a, const {{ typedef.name}} &b) noexcept {
    return
        tie({% for member in typedef.members %}a.{{ member.name }}{% if not loop.is_last %}, {% endif %}{% endfor %}) <
        tie({% for member in typedef.members %}b.{{ member.name }}{% if not loop.is_last %}, {% endif %}{% endfor %});
}

bool operator<=(const {{ typedef.name }} &a, const {{ typedef.name}} &b) noexcept {
    return !(b < a);
}

bool operator>(const {{ typedef.name }} &a, const {{ typedef.name}} &b) noexcept {
    return b < a;
}

bool operator>=(const {{ typedef.name }} &a, const {{ typedef.name}} &b) noexcept {
    return !(a < b);
}

## endfor
} // {% if namespace %}} // namespace {{ namespace }}{% endif %}

{% include "iostream_definitions" %}
{% include "hash_definitions" %}
